/**
 * @license
 * Copyright 2020 Dynatrace LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  html,
  property,
  CSSResult,
  TemplateResult,
  css,
  customElement,
  LitElement,
} from 'lit-element';

import { FluidDesignTokenAccessor, FluidDesignTokens } from './token-accessor';
import { FluidProviderTokenChangeEvent } from './provider-events';

/** Defines the possible layout density options. */
export type FluidLayoutDensity = 'default' | 'dense' | 'loose';

/** Defines the available themes. */
export type FluidTheme = 'abyss' | 'surface';

const supportsAdoptedStylesheets =
  'adoptedStyleSheets' in window.ShadowRoot.prototype;

// The provider itself cannot extend FluidElement
// since it would lead to a circular dependency.
@customElement('fluid-provider')
export class FluidProvider extends LitElement {
  /** Styles for the provider component */
  static get styles(): CSSResult {
    return css`
      :host {
        /**
        * Legibility definitions
        */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
      }
    `;
  }

  /**
   * Defines the theme that should be used for child components.
   * @attr
   * @type {'abyss' | 'surface'}
   * @default 'abyss'
   */
  @property({ type: String, reflect: true })
  get theme(): FluidTheme {
    return this._theme;
  }
  set theme(value: FluidTheme) {
    if (value !== this._theme) {
      const oldValue = this._theme;
      this._theme = value;
      this.requestUpdate('theme', oldValue);

      this._updateThemeOverrides();
      this._updateCustomProperties();
      this._dispatchTokenChangeEvent();
    }
  }
  private _theme: FluidTheme = 'abyss';

  /**
   * Defines the layout density inside the provider.
   * @attr
   * @type {'default' | 'dense' | 'loose'}
   * @default 'default'
   */
  @property({ type: String, reflect: true })
  get layout(): FluidLayoutDensity {
    return this._layout;
  }
  set layout(value: FluidLayoutDensity) {
    if (value !== this._layout) {
      const oldValue = this._layout;
      this._layout = value;
      this.requestUpdate('layout', oldValue);

      this._updateSpacingOverrides();
      this._updateCustomProperties();
      this._dispatchTokenChangeEvent();
    }
  }
  private _layout: FluidLayoutDensity = 'default';

  /**
   * Object with key-value pairs of all design tokens available on this provider.
   */
  get designTokens(): FluidDesignTokens {
    return this._tokenAccessor.tokens;
  }

  /**
   * DOM representation of styles generated by this component.
   *
   * Uses adopted stylesheets if supported or this component's style
   * attribute otherwise.
   */
  private _style: CSSStyleDeclaration;

  /** The design token accessor instance used to override and access tokens. */
  private _tokenAccessor: FluidDesignTokenAccessor = new FluidDesignTokenAccessor();

  /**
   * Maps values of the {@link FluidProvider#layout} property to layout density design tokens.
   */
  private readonly _layoutDensityMultiplicators: {
    [key in FluidLayoutDensity]: number;
  } = {
    // TODO: get rid of parseFloat() once we can build tokens with numeric values
    dense: parseFloat(this.designTokens.FLUID_LAYOUT_DENSE),
    default: parseFloat(this.designTokens.FLUID_LAYOUT_DEFAULT),
    loose: parseFloat(this.designTokens.FLUID_LAYOUT_LOOSE),
  };

  constructor() {
    super();

    // Sourced from https://github.com/microsoft/fast/blob/master/packages/web-components/fast-foundation/src/design-system-provider/design-system-provider.ts#L322
    if (supportsAdoptedStylesheets && this.shadowRoot !== null) {
      const sheet = new CSSStyleSheet();
      sheet.insertRule(':host{}');
      (this.shadowRoot as any).adoptedStyleSheets = [
        ...(this.shadowRoot as any).adoptedStyleSheets,
        sheet,
      ];

      this._style = (sheet.rules[0] as CSSStyleRule).style;
    } else {
      // Fallback if the browser doesn't support adopted stylesheets
      // See https://caniuse.com/#feat=mdn-api_documentorshadowroot_adoptedstylesheets
      this._style = this.style;
    }
  }

  /** @inheritdoc */
  connectedCallback(): void {
    super.connectedCallback();

    this._updateThemeOverrides();
    this._updateCustomProperties();
  }

  /**
   * Retrieves the value of the design token with the given name
   * @param name The name of the design token
   */
  getDesignTokenValue(name: string): any {
    return this.designTokens[name];
  }

  /**
   * Creates or overrides a design token with the given name.
   *
   * If no design token with the given name exists, it will be created.
   * Otherwise, the value will be overwritten on this provider only.
   * @param name Name of the design token
   * @param value New value of the design token
   */
  setToken(name: string, value: any): void {
    this._tokenAccessor.setToken(name, value);
    this._updateCustomProperty(name);
    this._dispatchTokenChangeEvent();
  }

  /**
   * Resets an overriden token to its initial value.
   *
   * If the token was created dynamically, it will be removed.
   * If an existing token was overwritten, its value will be reset.
   * @param name The name of the design token to reset
   */
  resetToken(name: string): void {
    this._tokenAccessor.resetToken(name);
    this._updateCustomProperty(name);
    this._dispatchTokenChangeEvent();
  }

  /**
   * Render function of the custom element. It is called when one of the
   * observedProperties (annotated with @property) changes.
   */
  render(): TemplateResult {
    return html`<slot></slot>`;
  }

  /** Sets a CSS custom property from a token name and value */
  private _setCustomPropertyFromToken(
    name: string,
    value: string | number,
  ): void {
    const propertyName = this._tokenAccessor.getCssPropertyName(name);
    const propertyValue = (value as string | number).toString();
    this._style.setProperty(propertyName, propertyValue);
  }

  /** Creates CSS custom properties for all tokens */
  private _updateCustomProperties(): void {
    for (const [name, value] of Object.entries(this.designTokens)) {
      if (typeof value !== 'string' && typeof value !== 'number') {
        continue;
      }

      this._setCustomPropertyFromToken(name, value);
    }
  }

  /** Creates a CSS custom property for the token with the given name */
  private _updateCustomProperty(tokenName: string): void {
    const value = this.designTokens[tokenName];
    if (typeof value !== 'string' && typeof value !== 'number') {
      return;
    }

    this._setCustomPropertyFromToken(tokenName, value);
  }

  /** Creates or updates color tokens for the current theme */
  private _updateThemeOverrides(): void {
    const themeTokens = this.designTokens.THEMES[this.theme.toUpperCase()];
    for (const [name, value] of Object.entries(themeTokens)) {
      this._tokenAccessor.setToken(name, value);
      this._updateCustomProperty(name);
    }
  }

  /** Overrides the spacing tokens in respect of the current layout density */
  private _updateSpacingOverrides(): void {
    const spacingTokens = Object.entries(
      this._tokenAccessor.originalTokens,
    ).filter(
      ([name, value]) =>
        name.startsWith('FLUID_SPACING') && typeof value === 'string',
    );
    const densityMultiplicator = this._layoutDensityMultiplicators[
      this._layout
    ];

    for (const [name, value] of spacingTokens) {
      // HACK: gets rid of the unit and assumes that all spacings are in pixels.
      // The design tokens should be changed to numeric values instead in the future.
      const valueWithoutUnit = parseInt((value as unknown) as string, 10);
      const densityAdjustedValue = Math.round(
        valueWithoutUnit * densityMultiplicator,
      );
      this._tokenAccessor.setToken(name, `${densityAdjustedValue}px`);
      this._updateCustomProperty(name);
    }
  }

  /** Creates and dispatches a token change event  */
  private _dispatchTokenChangeEvent(): void {
    this.dispatchEvent(new FluidProviderTokenChangeEvent(this.designTokens));
  }
}
